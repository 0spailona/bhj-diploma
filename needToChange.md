Дарья, здравствуйте. Спасибо за присланную работу. Прошу вас обратить внимание и поправить некоторые моменты:
* ++ В createRequest комментарий Если сделать DELETE как общепринято, сервер выдает 500 не совсем корректный. У вас счета удаляются без проблем (с формируемой формой), а вот транзакции не удаляются т.к. там не передаётся идентификатор транзакции (если выполнять клик по элементу иконки мусорки, а не по самой кнопки):

* ++ Запросов с методами -delete и head вообще не существует. Так что, массив methodsWithoutBody можно удалить и на 14-ой строке выполнять сравнение только с GET запросом. Только для этого метода вы должны формировать строку запроса (а для всех остальных формируется форма).
* ++ Вместо события loadend можно подписаться на событие load. Это событие выполняется тогда, когда запрос завершится успешно. Так что, не придётся проверять статус ответа.
* ++ Для действий пользователя (в классе User) стоит формировать промежуточный колбек (как в методах fetch и login)....В этих промежуточных колбеках необходимо выполнять взаимодействие с локальным хранилищем....В запросе logout действие unsetCurrent стоит выполнять внутри этого промежуточного колбека.
* ++ Функция callbackForFetch не используется. Так что, её можно удалить.
* ++ В Sidebar.initToggleButton условную конструкцию с методами remove и add классов можно убрать, а просто использовать toggle классов.
* ++ В конструкторах UI при валидации необходимо выбрасывать ошибки. У вас вызывается функция errors, которая просто выполняет вывод в консоль. Для выбрасывания ошибок используйте throw new Error(...)
* ++ В AsyncForm.getData реализацию можно сократить до пары строк:

getData() {
const formData = new FormData(this.element);
return Object.fromEntries(formData.entries());
}

* ++ В CreateTransactionForm.renderAccountsList вы сначала удаляете каждый элемент отдельно (с помощью цикла), а затем, в цикле (а точнее, с помощью метода forEach) каждый раз, переприсваиваете это свойство. Только не забывайте, что на каждое изменение DOM (которое у вас выполняется при пересвоении свойства innerHTML) перерисовывается вся страница. Это не очень оптимально (так часто перерисовывать всю страницу). Лучше один раз накопить всю разметку с помощью reduce и это накопленное значение (результата reduce) переприсваивать свойство innerHTML в одно действие: select.innerHTML = response.data.reduce(...);
* ++ Если реализовывать колбеки стрелочными функциями, то контекст не потеряется, а следовательно, его не придётся привязывать с помощью bind (как совет, можете поправить, чтобы не привязывать контекст).
* ++ Если выполнять клик по элементу транзакции (вне кнопки), то в консоли возникает ошибка TypeError: Cannot read properties of null (reading 'dataset'). Никаких ошибок не должно быть.
* ++ Метод getTransactionHTML начинается с get, что означает получить, а у вас метод ничего не возвращает (чтобы можно было получить). У вас метод отрисовывает элемент....Получается смысловая ошибка. Метод называется одним смыслом, а выполняет совсем другое.
* ++ Всё тоже самое в методе AccountsWidget.getAccountHTML.

Внесите, пожалуйста, правки, чтобы доработать свое решение и получить “зачет” по этому заданию.